package handlers

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"go-api-game/config"
	"go-api-game/utils"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

// saveImage handles image upload to Cloudinary with fallback to local storage
func saveImage(file io.Reader, header *multipart.FileHeader) (string, error) {
	// Read file bytes
	fileBytes, err := io.ReadAll(file)
	if err != nil {
		return "", fmt.Errorf("error reading image file: %v", err)
	}

	// Check file type
	allowedTypes := map[string]bool{
		".jpg": true, ".jpeg": true, ".png": true, ".gif": true,
		".webp": true, ".avif": true,
	}
	ext := strings.ToLower(filepath.Ext(header.Filename))
	if !allowedTypes[ext] {
		return "", fmt.Errorf("invalid file type. Allowed: jpg, jpeg, png, gif, webp, avif")
	}

	// Generate unique filename
	filename := fmt.Sprintf("game_%d%s", time.Now().UnixNano(), ext)

	// Try Cloudinary first
	if config.Cld != nil {
		imageURL, err := config.UploadImageFromBytes(fileBytes, filename)
		if err != nil {
			fmt.Printf("‚ùå Cloudinary upload failed, using local storage: %v\n", err)
			// Fallback to local storage
			return saveToLocalStorage(fileBytes, filename)
		}
		fmt.Printf("‚úÖ Image uploaded to Cloudinary: %s\n", imageURL)
		return imageURL, nil
	}

	// Use local storage if Cloudinary not configured
	return saveToLocalStorage(fileBytes, filename)
}

// saveToLocalStorage saves image to local file system
func saveToLocalStorage(fileBytes []byte, filename string) (string, error) {
	// Create uploads directory if not exists
	if _, err := os.Stat("uploads"); os.IsNotExist(err) {
		os.Mkdir("uploads", 0755)
	}

	filePath := filepath.Join("uploads", filename)

	err := os.WriteFile(filePath, fileBytes, 0644)
	if err != nil {
		return "", fmt.Errorf("error saving image locally: %v", err)
	}

	localURL := "/uploads/" + filename
	fmt.Printf("‚úÖ Image saved locally: %s\n", localURL)
	return localURL, nil
}

// deleteImage handles image deletion from both Cloudinary and local storage
func deleteImage(imageURL string) error {
	if imageURL == "" {
		return nil
	}

	// Check if it's a Cloudinary URL
	if strings.Contains(imageURL, "cloudinary.com") {
		// Delete from Cloudinary
		err := config.DeleteImage(imageURL)
		if err != nil {
			return fmt.Errorf("error deleting Cloudinary image: %v", err)
		}
		fmt.Printf("üóëÔ∏è Deleted Cloudinary image: %s\n", imageURL)
	} else {
		// Delete from local storage
		filePath := strings.TrimPrefix(imageURL, "/")
		if _, err := os.Stat(filePath); err == nil {
			err := os.Remove(filePath)
			if err != nil {
				return fmt.Errorf("error deleting local image: %v", err)
			}
			fmt.Printf("üóëÔ∏è Deleted local image: %s\n", filePath)
		}
	}
	return nil
}

// AdminAddGameHandler handles adding new games
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö
func AdminAddGameHandler(w http.ResponseWriter, r *http.Request) {
	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏°‡∏ò‡∏≠‡∏î POST ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	if r.Method != "POST" {
		utils.JSONError(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤ (JSON ‡∏´‡∏£‡∏∑‡∏≠ Form-data)
	contentType := r.Header.Get("Content-Type")

	// ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å request
	var req struct {
		Name        string  `json:"name"`         // ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡∏° (‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)
		Price       float64 `json:"price"`        // ‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏Å‡∏° (‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)
		CategoryID  int     `json:"category_id"`  // ID ‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà (‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)
		Description string  `json:"description"`  // ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÄ‡∏Å‡∏°
		ReleaseDate string  `json:"release_date"` // ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏á‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢ (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
	}

	var imageURL string // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö URL ‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡πÄ‡∏Å‡∏°

	// ‡∏Å‡∏£‡∏ì‡∏µ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö Form-data (‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û)
	if strings.Contains(contentType, "multipart/form-data") {
		// ‡πÅ‡∏¢‡∏Å‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå form data ‡∏Ç‡∏ô‡∏≤‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 10MB
		err := r.ParseMultipartForm(10 << 20) // 10 MB limit
		if err != nil {
			utils.JSONError(w, "Error parsing form data", http.StatusBadRequest)
			return
		}

		// ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏ü‡∏≠‡∏£‡πå‡∏°
		req.Name = r.FormValue("name")
		priceStr := r.FormValue("price")
		categoryIDStr := r.FormValue("category_id")
		req.Description = r.FormValue("description")
		req.ReleaseDate = r.FormValue("release_date") // Optional

		// ‡πÅ‡∏õ‡∏•‡∏á‡∏™‡∏ï‡∏£‡∏¥‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
		if priceStr != "" {
			req.Price, err = strconv.ParseFloat(priceStr, 64)
			if err != nil {
				utils.JSONError(w, "Invalid price format", http.StatusBadRequest)
				return
			}
		}

		if categoryIDStr != "" {
			req.CategoryID, err = strconv.Atoi(categoryIDStr)
			if err != nil {
				utils.JSONError(w, "Invalid category ID", http.StatusBadRequest)
				return
			}
		}

		// ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û
		file, header, err := r.FormFile("image")
		if err == nil {
			defer file.Close()

			// ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û
			imageURL, err = saveImage(file, header)
			if err != nil {
				utils.JSONError(w, "Error uploading image: "+err.Error(), http.StatusInternalServerError)
				return
			}
		}
	} else {
		// ‡∏Å‡∏£‡∏ì‡∏µ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö JSON (‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û)
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.JSONError(w, "Invalid request body", http.StatusBadRequest)
			return
		}
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
	if req.Name == "" {
		utils.JSONError(w, "Game name is required", http.StatusBadRequest)
		return
	}

	if req.Price <= 0 {
		utils.JSONError(w, "Price must be greater than 0", http.StatusBadRequest)
		return
	}

	if req.CategoryID <= 0 {
		utils.JSONError(w, "Valid category ID is required", http.StatusBadRequest)
		return
	}

	// ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏á‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢
	var releaseDate interface{}
	if req.ReleaseDate != "" {
		// ‡∏ñ‡πâ‡∏≤‡∏£‡∏±‡∏ö release_date ‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
		date, err := time.Parse("2006-01-02", req.ReleaseDate)
		if err != nil {
			utils.JSONError(w, "Invalid release date format. Use YYYY-MM-DD", http.StatusBadRequest)
			return
		}
		releaseDate = date
		fmt.Printf("üìÖ Using provided release date: %s\n", req.ReleaseDate)
	} else {
		// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö release_date ‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
		currentDate := time.Now().Format("2006-01-02")
		releaseDate = currentDate
		fmt.Printf("üìÖ Using current date as release date: %s\n", currentDate)
	}

	// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	var result sql.Result
	var err error

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á SQL ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ release_date ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	if releaseDate != nil {
		result, err = db.Exec(`
			INSERT INTO games (name, price, category_id, image_url, description, release_date)
			VALUES (?, ?, ?, ?, ?, ?)
		`, req.Name, req.Price, req.CategoryID, imageURL, req.Description, releaseDate)
	} else {
		result, err = db.Exec(`
			INSERT INTO games (name, price, category_id, image_url, description)
			VALUES (?, ?, ?, ?, ?)
		`, req.Name, req.Price, req.CategoryID, imageURL, req.Description)
	}

	if err != nil {
		fmt.Printf("‚ùå Error adding game: %v\n", err)
		// ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ß‡πâ‡∏ñ‡πâ‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
		if imageURL != "" {
			deleteImage(imageURL)
		}
		utils.JSONError(w, "Error adding game: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// ‡∏î‡∏∂‡∏á ID ‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°
	gameID, _ := result.LastInsertId()

	// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢ 0
	_, err = db.Exec("INSERT INTO ranking (game_id, sales_count) VALUES (?, 0)", gameID)
	if err != nil {
		fmt.Printf("‚ö†Ô∏è Error initializing ranking: %v\n", err)
		// ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡πÅ‡∏°‡πâ‡∏ß‡πà‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö‡∏à‡∏∞‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
	}

	fmt.Printf("‚úÖ Game added successfully: ID=%d, Name=%s\n", gameID, req.Name)

	// ‡∏™‡πà‡∏á response ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á client
	utils.JSONResponse(w, map[string]interface{}{
		"message": "Game added successfully",
		"game_id": gameID,
		"release_date": func() string {
			// ‡πÅ‡∏õ‡∏•‡∏á releaseDate ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏ï‡∏£‡∏¥‡∏á‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö YYYY-MM-DD
			if date, ok := releaseDate.(time.Time); ok {
				return date.Format("2006-01-02")
			}
			return releaseDate.(string)
		}(),
	}, http.StatusCreated)
}

// AdminUpdateGameHandler handles updating games
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
func AdminUpdateGameHandler(w http.ResponseWriter, r *http.Request) {
	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏°‡∏ò‡∏≠‡∏î PUT ‡∏´‡∏£‡∏∑‡∏≠ PATCH
	if r.Method != "PUT" && r.Method != "PATCH" {
		utils.JSONError(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// ‡∏î‡∏∂‡∏á game_id ‡∏à‡∏≤‡∏Å URL path
	// ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á URL: /admin/games/123 ‚Üí gameID = 123
	pathParts := strings.Split(r.URL.Path, "/")
	gameIDStr := pathParts[len(pathParts)-1]
	gameID, err := strconv.Atoi(gameIDStr)
	if err != nil {
		utils.JSONError(w, "Invalid game ID", http.StatusBadRequest)
		return
	}

	fmt.Printf("üîç Admin updating game ID: %d\n", gameID)

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
	contentType := r.Header.Get("Content-Type")
	var req struct {
		Name        string  `json:"name"`
		Price       float64 `json:"price"`
		CategoryID  int     `json:"category_id"`
		Description string  `json:"description"`
		ReleaseDate string  `json:"release_date"`
	}

	var imageURL string

	// ‡∏Å‡∏£‡∏ì‡∏µ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö Form-data
	if strings.Contains(contentType, "multipart/form-data") {
		err = r.ParseMultipartForm(10 << 20)
		if err != nil {
			utils.JSONError(w, "Error parsing form data", http.StatusBadRequest)
			return
		}

		// ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏ü‡∏≠‡∏£‡πå‡∏°
		req.Name = r.FormValue("name")
		priceStr := r.FormValue("price")
		categoryIDStr := r.FormValue("category_id")
		req.Description = r.FormValue("description")
		req.ReleaseDate = r.FormValue("release_date")

		// ‡πÅ‡∏õ‡∏•‡∏á‡∏™‡∏ï‡∏£‡∏¥‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
		if priceStr != "" {
			req.Price, err = strconv.ParseFloat(priceStr, 64)
			if err != nil {
				utils.JSONError(w, "Invalid price format", http.StatusBadRequest)
				return
			}
		}

		if categoryIDStr != "" {
			req.CategoryID, err = strconv.Atoi(categoryIDStr)
			if err != nil {
				utils.JSONError(w, "Invalid category ID", http.StatusBadRequest)
				return
			}
		}

		// ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà
		file, header, err := r.FormFile("image")
		if err == nil {
			defer file.Close()

			// ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û
			imageURL, err = saveImage(file, header)
			if err != nil {
				utils.JSONError(w, "Error uploading image: "+err.Error(), http.StatusInternalServerError)
				return
			}
		}
	} else {
		// ‡∏Å‡∏£‡∏ì‡∏µ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö JSON
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.JSONError(w, "Invalid request body", http.StatusBadRequest)
			return
		}
	}

	// ‡∏î‡∏∂‡∏á URL ‡∏†‡∏≤‡∏û‡πÄ‡∏Å‡πà‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏ö‡πÉ‡∏ô‡∏†‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà)
	var oldImageURL sql.NullString
	if imageURL != "" {
		db.QueryRow("SELECT image_url FROM games WHERE id = ?", gameID).Scan(&oldImageURL)
	}

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÅ‡∏ö‡∏ö‡πÑ‡∏î‡∏ô‡∏≤‡∏°‡∏¥‡∏Å‡∏ï‡∏≤‡∏°‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏°‡∏≤
	updateFields := []string{} // ‡πÄ‡∏Å‡πá‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó
	args := []interface{}{}    // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á SQL

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ü‡∏¥‡∏•‡∏î‡πå‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏•‡∏á‡πÉ‡∏ô query ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ñ‡πà‡∏≤
	if req.Name != "" {
		updateFields = append(updateFields, "name = ?")
		args = append(args, req.Name)
	}

	if req.Price > 0 {
		updateFields = append(updateFields, "price = ?")
		args = append(args, req.Price)
	}

	if req.CategoryID > 0 {
		updateFields = append(updateFields, "category_id = ?")
		args = append(args, req.CategoryID)
	}

	if req.Description != "" {
		updateFields = append(updateFields, "description = ?")
		args = append(args, req.Description)
	}

	if req.ReleaseDate != "" {
		date, err := time.Parse("2006-01-02", req.ReleaseDate)
		if err != nil {
			utils.JSONError(w, "Invalid release date format. Use YYYY-MM-DD", http.StatusBadRequest)
			return
		}
		updateFields = append(updateFields, "release_date = ?")
		args = append(args, date)
	}

	if imageURL != "" {
		updateFields = append(updateFields, "image_url = ?")
		args = append(args, imageURL)
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	if len(updateFields) == 0 {
		utils.JSONError(w, "No fields to update", http.StatusBadRequest)
		return
	}

	// ‡πÄ‡∏û‡∏¥‡πà‡∏° game ID ‡πÑ‡∏õ‡∏¢‡∏±‡∏á args ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç WHERE
	args = append(args, gameID)

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞ execute ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á UPDATE
	query := fmt.Sprintf("UPDATE games SET %s WHERE id = ?", strings.Join(updateFields, ", "))
	result, err := db.Exec(query, args...)
	if err != nil {
		fmt.Printf("‚ùå Error updating game: %v\n", err)
		// ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
		if imageURL != "" {
			deleteImage(imageURL)
		}
		utils.JSONError(w, "Error updating game: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÅ‡∏ñ‡∏ß‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		if imageURL != "" {
			deleteImage(imageURL)
		}
		utils.JSONError(w, "Game not found", http.StatusNotFound)
		return
	}

	// ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡πÄ‡∏Å‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà
	if imageURL != "" && oldImageURL.Valid && oldImageURL.String != "" {
		err := deleteImage(oldImageURL.String)
		if err != nil {
			fmt.Printf("‚ö†Ô∏è Error deleting old image: %v\n", err)
		} else {
			fmt.Printf("üóëÔ∏è Deleted old image: %s\n", oldImageURL.String)
		}
	}

	fmt.Printf("‚úÖ Game updated successfully: ID=%d\n", gameID)

	// ‡∏™‡πà‡∏á response ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
	utils.JSONResponse(w, map[string]interface{}{
		"message": "Game updated successfully",
		"game_id": gameID,
	}, http.StatusOK)
}

// AdminDeleteGameHandler handles deleting games
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡∏ö‡πÄ‡∏Å‡∏°‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö
func AdminDeleteGameHandler(w http.ResponseWriter, r *http.Request) {
	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏°‡∏ò‡∏≠‡∏î DELETE ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	if r.Method != "DELETE" {
		utils.JSONError(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// ‡∏î‡∏∂‡∏á game_id ‡∏à‡∏≤‡∏Å URL path
	pathParts := strings.Split(r.URL.Path, "/")
	gameIDStr := pathParts[len(pathParts)-1]
	gameID, err := strconv.Atoi(gameIDStr)
	if err != nil {
		utils.JSONError(w, "Invalid game ID", http.StatusBadRequest)
		return
	}

	fmt.Printf("üîç Admin deleting game ID: %d\n", gameID)

	// ‡∏î‡∏∂‡∏á URL ‡∏†‡∏≤‡∏û‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏ö (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå)
	var imageURL sql.NullString
	err = db.QueryRow("SELECT image_url FROM games WHERE id = ?", gameID).Scan(&imageURL)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.JSONError(w, "Game not found", http.StatusNotFound)
		} else {
			utils.JSONError(w, "Error fetching game", http.StatusInternalServerError)
		}
		return
	}

	// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô transaction ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	tx, err := db.Begin()
	if err != nil {
		utils.JSONError(w, "Error starting transaction", http.StatusInternalServerError)
		return
	}

	// ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô foreign key constraint violations

	// 1. ‡∏•‡∏ö‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á ranking (‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö)
	_, err = tx.Exec("DELETE FROM ranking WHERE game_id = ?", gameID)
	if err != nil {
		tx.Rollback() // ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å transaction ‡∏ñ‡πâ‡∏≤‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
		utils.JSONError(w, "Error deleting game ranking", http.StatusInternalServerError)
		return
	}

	// 2. ‡∏•‡∏ö‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á cart_items (‡πÄ‡∏Å‡∏°‡πÉ‡∏ô‡∏ï‡∏∞‡∏Å‡∏£‡πâ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ)
	_, err = tx.Exec("DELETE FROM cart_items WHERE game_id = ?", gameID)
	if err != nil {
		tx.Rollback()
		utils.JSONError(w, "Error deleting game from carts", http.StatusInternalServerError)
		return
	}

	// 3. ‡∏•‡∏ö‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á purchase_items (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡∏°‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠)
	_, err = tx.Exec("DELETE pi FROM purchase_items pi WHERE pi.game_id = ?", gameID)
	if err != nil {
		tx.Rollback()
		utils.JSONError(w, "Error deleting game purchase records", http.StatusInternalServerError)
		return
	}

	// 4. ‡∏•‡∏ö‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á purchased_games (‡πÄ‡∏Å‡∏°‡πÉ‡∏ô‡∏Ñ‡∏•‡∏±‡∏á‡πÄ‡∏Å‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ)
	_, err = tx.Exec("DELETE FROM purchased_games WHERE game_id = ?", gameID)
	if err != nil {
		tx.Rollback()
		utils.JSONError(w, "Error deleting game from user libraries", http.StatusInternalServerError)
		return
	}

	// 5. ‡∏•‡∏ö‡πÄ‡∏Å‡∏°‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á games (‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏Å)
	result, err := tx.Exec("DELETE FROM games WHERE id = ?", gameID)
	if err != nil {
		tx.Rollback()
		utils.JSONError(w, "Error deleting game", http.StatusInternalServerError)
		return
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÄ‡∏Å‡∏°‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		tx.Rollback()
		utils.JSONError(w, "Game not found", http.StatusNotFound)
		return
	}

	// ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô transaction
	if err := tx.Commit(); err != nil {
		utils.JSONError(w, "Error committing transaction", http.StatusInternalServerError)
		return
	}

	// ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
	if imageURL.Valid && imageURL.String != "" {
		err := deleteImage(imageURL.String)
		if err != nil {
			fmt.Printf("‚ö†Ô∏è Error deleting game image: %v\n", err)
		} else {
			fmt.Printf("üóëÔ∏è Deleted game image: %s\n", imageURL.String)
		}
	}

	fmt.Printf("‚úÖ Game deleted successfully: ID=%d\n", gameID)

	// ‡∏™‡πà‡∏á response ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
	utils.JSONResponse(w, map[string]interface{}{
		"message": "Game deleted successfully",
		"game_id": gameID,
	}, http.StatusOK)
}

// AdminUsersHandler handles admin user management
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÑ‡∏°‡πà‡∏£‡∏ß‡∏° admin)
func AdminUsersHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		utils.JSONError(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	fmt.Printf("üîç Admin fetching all users (excluding admins)\n")

	// ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà admin ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
	rows, err := db.Query(`
		SELECT id, username, email, role, 
		       DATE_FORMAT(created_at, '%Y-%m-%d %H:%i:%s') as created_date,
		       wallet_balance
		FROM users
		WHERE role != 'admin'
		ORDER BY created_at DESC
	`)
	if err != nil {
		fmt.Printf("‚ùå Error fetching users: %v\n", err)
		utils.JSONError(w, "Error fetching users: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var users []map[string]interface{}
	count := 0

	// ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß
	for rows.Next() {
		var id int
		var username, email, role string
		var createdDate string
		var walletBalance float64

		if err := rows.Scan(&id, &username, &email, &role, &createdDate, &walletBalance); err != nil {
			fmt.Printf("‚ùå Error scanning user row: %v\n", err)
			continue
		}

		// ‡∏™‡∏£‡πâ‡∏≤‡∏á object ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
		user := map[string]interface{}{
			"id":             id,
			"username":       username,
			"email":          email,
			"role":           role,
			"created_at":     createdDate,
			"wallet_balance": walletBalance,
		}

		users = append(users, user)
		count++
		fmt.Printf("‚úÖ User: ID=%d, Username=%s, Role=%s\n", id, username, role)
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	if err = rows.Err(); err != nil {
		fmt.Printf("‚ùå Error during users rows iteration: %v\n", err)
		utils.JSONError(w, "Error processing users", http.StatusInternalServerError)
		return
	}

	fmt.Printf("‚úÖ Total users found (excluding admins): %d\n", count)

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ users ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô nil
	if users == nil {
		users = []map[string]interface{}{}
	}

	// ‡∏™‡πà‡∏á response ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
	utils.JSONResponse(w, users, http.StatusOK)
}

// AdminStatsHandler handles admin statistics
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö
func AdminStatsHandler(w http.ResponseWriter, r *http.Request) {
	// ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
	var stats struct {
		TotalUsers     int     `json:"total_users"`     // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
		TotalGames     int     `json:"total_games"`     // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Å‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
		TotalSales     float64 `json:"total_sales"`     // ‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
		TotalPurchases int     `json:"total_purchases"` // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
	}

	// ‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
	db.QueryRow("SELECT COUNT(*) FROM users").Scan(&stats.TotalUsers)

	// ‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Å‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
	db.QueryRow("SELECT COUNT(*) FROM games").Scan(&stats.TotalGames)

	// ‡∏î‡∏∂‡∏á‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÉ‡∏ä‡πâ COALESCE ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô NULL)
	db.QueryRow("SELECT COALESCE(SUM(final_amount), 0) FROM purchases").Scan(&stats.TotalSales)

	// ‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
	db.QueryRow("SELECT COUNT(*) FROM purchases").Scan(&stats.TotalPurchases)

	// ‡∏™‡πà‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
	utils.JSONResponse(w, stats, http.StatusOK)
}

// AdminTransactionsHandler handles admin transaction management
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö
func AdminTransactionsHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Printf("üí∞ AdminTransactionsHandler: %s %s\n", r.Method, r.URL.Path)

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏°‡∏ò‡∏≠‡∏î‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
	switch r.Method {
	case "GET":
		getAllTransactions(w, r) // ‡∏î‡∏∂‡∏á‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
	default:
		utils.JSONError(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// AdminUserTransactionsHandler handles user-specific transaction management for admin
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö
func AdminUserTransactionsHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Printf("üí∞ AdminUserTransactionsHandler: %s %s\n", r.Method, r.URL.Path)

	// ‡πÅ‡∏¢‡∏Å user ID ‡∏à‡∏≤‡∏Å URL path
	// ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á URL: /admin/transactions/user/123 ‚Üí userID = 123
	pathParts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
	if len(pathParts) < 4 {
		utils.JSONError(w, "User ID required", http.StatusBadRequest)
		return
	}

	userID, err := strconv.Atoi(pathParts[3])
	if err != nil {
		utils.JSONError(w, "Invalid user ID", http.StatusBadRequest)
		return
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏°‡∏ò‡∏≠‡∏î‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
	switch r.Method {
	case "GET":
		getUserTransactions(w, r, userID) // ‡∏î‡∏∂‡∏á‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏ô
	default:
		utils.JSONError(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// GET /admin/transactions - ‡∏î‡∏∂‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö (‡∏°‡∏µ pagination ‡πÅ‡∏•‡∏∞ filtering)
func getAllTransactions(w http.ResponseWriter, r *http.Request) {
	fmt.Println("üîç Fetching all transactions")

	// ‡∏£‡∏±‡∏ö query parameters ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö filtering ‡πÅ‡∏•‡∏∞ pagination
	query := r.URL.Query()
	transactionType := query.Get("type") // ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏° (‡∏ù‡∏≤‡∏Å‡πÄ‡∏á‡∏¥‡∏ô, ‡∏ñ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô, ‡∏ã‡∏∑‡πâ‡∏≠‡πÄ‡∏Å‡∏°)
	limitStr := query.Get("limit")       // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤
	offsetStr := query.Get("offset")     // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô

	// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ default values
	limit := 100
	offset := 0

	// ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ limit ‡πÅ‡∏•‡∏∞ offset ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 {
			limit = l
		}
	}
	if offsetStr != "" {
		if o, err := strconv.Atoi(offsetStr); err == nil && o >= 0 {
			offset = o
		}
	}

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á SQL ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
	baseQuery := `
		SELECT 
			t.id, t.user_id, u.username, t.type, t.amount, 
			t.description, DATE_FORMAT(t.created_at, '%Y-%m-%d %H:%i:%s') as created_at
		FROM user_transactions t
		LEFT JOIN users u ON t.user_id = u.id
	`
	var args []interface{}
	whereClauses := []string{}

	// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç WHERE ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°
	if transactionType != "" {
		whereClauses = append(whereClauses, "t.type = ?")
		args = append(args, transactionType)
	}

	// ‡∏£‡∏ß‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç WHERE ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
	if len(whereClauses) > 0 {
		baseQuery += " WHERE " + strings.Join(whereClauses, " AND ")
	}

	// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÅ‡∏•‡∏∞ pagination
	baseQuery += " ORDER BY t.created_at DESC LIMIT ? OFFSET ?"
	args = append(args, limit, offset)

	// Execute query
	rows, err := db.Query(baseQuery, args...)
	if err != nil {
		fmt.Printf("‚ùå Error fetching transactions: %v\n", err)
		utils.JSONError(w, "Error fetching transactions", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var transactions []map[string]interface{}
	count := 0

	// ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏µ‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß
	for rows.Next() {
		var id, userID int
		var username, transactionType, description, createdAt string
		var amount float64

		err := rows.Scan(&id, &userID, &username, &transactionType, &amount, &description, &createdAt)
		if err != nil {
			fmt.Printf("‚ùå Error scanning transaction row: %v\n", err)
			continue
		}

		// ‡∏™‡∏£‡πâ‡∏≤‡∏á object ‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°
		transaction := map[string]interface{}{
			"id":          id,
			"user_id":     userID,
			"user_name":   username,
			"type":        transactionType,
			"amount":      amount,
			"description": description,
			"created_at":  createdAt,
		}

		transactions = append(transactions, transaction)
		count++
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	if err = rows.Err(); err != nil {
		fmt.Printf("‚ùå Error during rows iteration: %v\n", err)
		utils.JSONError(w, "Error processing transactions", http.StatusInternalServerError)
		return
	}

	// ‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô total ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö pagination
	var totalCount int
	countQuery := `
		SELECT COUNT(*) 
		FROM user_transactions t
		LEFT JOIN users u ON t.user_id = u.id
	`
	if len(whereClauses) > 0 {
		countQuery += " WHERE " + strings.Join(whereClauses, " AND ")
	}
	err = db.QueryRow(countQuery, args[:len(args)-2]...).Scan(&totalCount)
	if err != nil {
		fmt.Printf("‚ùå Error counting transactions: %v\n", err)
		totalCount = count
	}

	fmt.Printf("‚úÖ Total transactions found: %d (showing %d)\n", totalCount, count)

	// ‡∏™‡πà‡∏á response ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• pagination
	utils.JSONResponse(w, map[string]interface{}{
		"transactions": transactions,
		"total":        totalCount,
		"limit":        limit,
		"offset":       offset,
		"count":        count,
		"success":      true,
	}, http.StatusOK)
}

// GET /admin/transactions/user/{userID} - ‡∏î‡∏∂‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏ô
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏ô (‡∏°‡∏µ pagination ‡πÅ‡∏•‡∏∞ filtering)
func getUserTransactions(w http.ResponseWriter, r *http.Request, userID int) {
	fmt.Printf("üîç Fetching transactions for user: ID=%d\n", userID)

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
	var username string
	err := db.QueryRow("SELECT username FROM users WHERE id = ?", userID).Scan(&username)
	if err != nil {
		if err == sql.ErrNoRows {
			utils.JSONError(w, "User not found", http.StatusNotFound)
		} else {
			utils.JSONError(w, "Error checking user", http.StatusInternalServerError)
		}
		return
	}

	// ‡∏£‡∏±‡∏ö query parameters
	query := r.URL.Query()
	transactionType := query.Get("type")
	limitStr := query.Get("limit")
	offsetStr := query.Get("offset")

	// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ default values
	limit := 50
	offset := 0

	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 {
			limit = l
		}
	}
	if offsetStr != "" {
		if o, err := strconv.Atoi(offsetStr); err == nil && o >= 0 {
			offset = o
		}
	}

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á SQL
	baseQuery := `
		SELECT 
			t.id, t.type, t.amount, t.description, 
			DATE_FORMAT(t.created_at, '%Y-%m-%d %H:%i:%s') as created_at
		FROM user_transactions t
		WHERE t.user_id = ?
	`
	var args []interface{}
	args = append(args, userID)

	// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
	if transactionType != "" {
		baseQuery += " AND t.type = ?"
		args = append(args, transactionType)
	}

	// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÅ‡∏•‡∏∞ pagination
	baseQuery += " ORDER BY t.created_at DESC LIMIT ? OFFSET ?"
	args = append(args, limit, offset)

	// Execute query
	rows, err := db.Query(baseQuery, args...)
	if err != nil {
		fmt.Printf("‚ùå Error fetching user transactions: %v\n", err)
		utils.JSONError(w, "Error fetching user transactions", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var transactions []map[string]interface{}
	count := 0

	// ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏µ‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß
	for rows.Next() {
		var id int
		var transactionType, description, createdAt string
		var amount float64

		err := rows.Scan(&id, &transactionType, &amount, &description, &createdAt)
		if err != nil {
			fmt.Printf("‚ùå Error scanning user transaction row: %v\n", err)
			continue
		}

		// ‡∏™‡∏£‡πâ‡∏≤‡∏á object ‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°
		transaction := map[string]interface{}{
			"id":          id,
			"user_id":     userID,
			"user_name":   username,
			"type":        transactionType,
			"amount":      amount,
			"description": description,
			"created_at":  createdAt,
		}

		transactions = append(transactions, transaction)
		count++
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	if err = rows.Err(); err != nil {
		fmt.Printf("‚ùå Error during rows iteration: %v\n", err)
		utils.JSONError(w, "Error processing user transactions", http.StatusInternalServerError)
		return
	}

	// ‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô total ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö pagination
	var totalCount int
	countQuery := "SELECT COUNT(*) FROM user_transactions WHERE user_id = ?"
	if transactionType != "" {
		countQuery += " AND type = ?"
		err = db.QueryRow(countQuery, userID, transactionType).Scan(&totalCount)
	} else {
		err = db.QueryRow(countQuery, userID).Scan(&totalCount)
	}
	if err != nil {
		fmt.Printf("‚ùå Error counting user transactions: %v\n", err)
		totalCount = count
	}

	// ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
	var userUsername, userEmail, userCreatedAt string
	var userWalletBalance float64

	err = db.QueryRow(`
		SELECT username, email, wallet_balance, DATE_FORMAT(created_at, '%Y-%m-%d %H:%i:%s') as created_at 
		FROM users WHERE id = ?
	`, userID).Scan(&userUsername, &userEmail, &userWalletBalance, &userCreatedAt)

	userData := make(map[string]interface{})
	if err != nil {
		fmt.Printf("‚ùå Error fetching user data: %v\n", err)
		userData = map[string]interface{}{
			"username": username,
			"error":    "Could not fetch full user details",
		}
	} else {
		userData = map[string]interface{}{
			"username":       userUsername,
			"email":          userEmail,
			"wallet_balance": userWalletBalance,
			"created_at":     userCreatedAt,
		}
	}

	fmt.Printf("‚úÖ Transactions found for user %s: %d (showing %d)\n", username, totalCount, count)

	// ‡∏™‡πà‡∏á response ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
	utils.JSONResponse(w, map[string]interface{}{
		"transactions": transactions,
		"user":         userData,
		"total":        totalCount,
		"limit":        limit,
		"offset":       offset,
		"count":        count,
		"success":      true,
	}, http.StatusOK)
}
